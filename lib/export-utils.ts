import { jsPDF } from 'jspdf';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, ExternalHyperlink } from 'docx';
import { Citation } from '@/stores/citations-store';

interface ExportOptions {
  title: string;
  content: string;
  citations: Citation[];
  query?: string;
  date?: Date;
}

/**
 * Export research report to PDF
 */
export async function exportToPdf(options: ExportOptions): Promise<void> {
  const { title, content, citations, query, date = new Date() } = options;
  const pdf = new jsPDF();

  const pageWidth = pdf.internal.pageSize.getWidth();
  const margin = 20;
  const contentWidth = pageWidth - margin * 2;

  let yPos = 20;

  // Header with Axiom branding
  pdf.setFontSize(10);
  pdf.setTextColor(128, 128, 128);
  pdf.text('Axiom Research Agent', margin, yPos);
  pdf.text(date.toLocaleDateString(), pageWidth - margin, yPos, { align: 'right' });
  yPos += 15;

  // Title
  pdf.setFontSize(24);
  pdf.setTextColor(0, 0, 0);
  pdf.text(title || 'Research Report', margin, yPos);
  yPos += 10;

  // Query (if provided)
  if (query) {
    pdf.setFontSize(12);
    pdf.setTextColor(100, 100, 100);
    pdf.text(`Query: ${query}`, margin, yPos);
    yPos += 10;
  }

  // Divider
  pdf.setDrawColor(200, 200, 200);
  pdf.line(margin, yPos, pageWidth - margin, yPos);
  yPos += 10;

  // Content - strip markdown and format
  pdf.setFontSize(11);
  pdf.setTextColor(40, 40, 40);

  const plainContent = stripMarkdown(content);
  const lines = pdf.splitTextToSize(plainContent, contentWidth);

  for (const line of lines) {
    if (yPos > 270) {
      pdf.addPage();
      yPos = 20;
    }
    pdf.text(line, margin, yPos);
    yPos += 6;
  }

  // Sources Section
  if (citations.length > 0) {
    if (yPos > 240) {
      pdf.addPage();
      yPos = 20;
    }

    yPos += 10;
    pdf.setFontSize(14);
    pdf.setTextColor(0, 0, 0);
    pdf.text('Sources', margin, yPos);
    yPos += 8;

    pdf.setFontSize(10);
    pdf.setTextColor(60, 60, 60);

    for (const citation of citations) {
      if (yPos > 270) {
        pdf.addPage();
        yPos = 20;
      }
      const citationText = `[${citation.index}] ${citation.title}`;
      pdf.text(citationText, margin, yPos);
      yPos += 5;
      pdf.setTextColor(100, 100, 200);
      pdf.text(citation.url, margin + 5, yPos);
      pdf.setTextColor(60, 60, 60);
      yPos += 7;
    }
  }

  // Footer
  const pageCount = pdf.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    pdf.setPage(i);
    pdf.setFontSize(8);
    pdf.setTextColor(150, 150, 150);
    pdf.text(
      `Generated by Axiom | Page ${i} of ${pageCount}`,
      pageWidth / 2,
      pdf.internal.pageSize.getHeight() - 10,
      { align: 'center' }
    );
  }

  // Download
  const fileName = `axiom-report-${date.toISOString().split('T')[0]}.pdf`;
  pdf.save(fileName);
}

/**
 * Export research report to DOCX
 */
export async function exportToDocx(options: ExportOptions): Promise<void> {
  const { title, content, citations, query, date = new Date() } = options;

  const children: (Paragraph)[] = [];

  // Header
  children.push(
    new Paragraph({
      children: [
        new TextRun({ text: 'Axiom Research Agent', size: 20, color: '808080' }),
        new TextRun({ text: `    ${date.toLocaleDateString()}`, size: 20, color: '808080' }),
      ],
    })
  );

  // Title
  children.push(
    new Paragraph({
      text: title || 'Research Report',
      heading: HeadingLevel.HEADING_1,
      spacing: { before: 400, after: 200 },
    })
  );

  // Query
  if (query) {
    children.push(
      new Paragraph({
        children: [
          new TextRun({ text: 'Query: ', bold: true }),
          new TextRun({ text: query, italics: true }),
        ],
        spacing: { after: 200 },
      })
    );
  }

  // Content paragraphs
  const plainContent = stripMarkdown(content);
  const paragraphs = plainContent.split('\n\n');

  for (const para of paragraphs) {
    if (para.trim()) {
      children.push(
        new Paragraph({
          text: para.trim(),
          spacing: { after: 200 },
        })
      );
    }
  }

  // Sources Section
  if (citations.length > 0) {
    children.push(
      new Paragraph({
        text: 'Sources',
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 400, after: 200 },
      })
    );

    for (const citation of citations) {
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: `[${citation.index}] ${citation.title} - ` }),
            new ExternalHyperlink({
              children: [
                new TextRun({
                  text: citation.url,
                  style: 'Hyperlink',
                }),
              ],
              link: citation.url,
            }),
          ],
          spacing: { after: 100 },
        })
      );
    }
  }

  // Footer
  children.push(
    new Paragraph({
      children: [
        new TextRun({ text: 'Generated by Axiom Research Agent', size: 18, color: '999999' }),
      ],
      spacing: { before: 600 },
    })
  );

  const doc = new Document({
    sections: [{ children }],
  });

  const blob = await Packer.toBlob(doc);
  const fileName = `axiom-report-${date.toISOString().split('T')[0]}.docx`;

  // Download
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  a.click();
  URL.revokeObjectURL(url);
}

/**
 * Strip markdown formatting for plain text export
 */
function stripMarkdown(text: string): string {
  return text
    // Remove headers
    .replace(/#{1,6}\s+/g, '')
    // Remove bold/italic
    .replace(/\*\*([^*]+)\*\*/g, '$1')
    .replace(/\*([^*]+)\*/g, '$1')
    .replace(/__([^_]+)__/g, '$1')
    .replace(/_([^_]+)_/g, '$1')
    // Remove links but keep text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
    // Remove code blocks
    .replace(/```[\s\S]*?```/g, '')
    .replace(/`([^`]+)`/g, '$1')
    // Remove bullet points
    .replace(/^\s*[-*+]\s+/gm, 'â€¢ ')
    // Clean up extra whitespace
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

/**
 * Extract title from markdown content
 */
export function extractTitle(content: string): string {
  const match = content.match(/^#\s+(.+)$/m);
  return match ? match[1] : 'Research Report';
}
